Description: 1.4.20.3 patch for Debian
Once 1.4.20.3 is released, (part of) this patch can be dropped
 .
 iscsitarget (1.4.20.2-6) unstable; urgency=low
 .
   * SVN 1.4.20@453 - Co-ordinated with upstream on the stability of the tree
   * [494142b] Drop double installation of upstream changelog.
     Thanks to Christian Pernegger (Closes: #633005)
   * [71de4f8] Add package linux-headers to Recommends.
     Thanks to George Shuklin (Closes: 636157, 628428)
   * [8344c44] Add support to provide daemon options.
     Thanks to Alfredo Sola, Robbert Rijkse (Closes: 609582, 545536)
   * [8208ade] Drop debian/30-iscsitarget.conf. (Closes: 636497)
     We should not play with kernel sysct knobs right from the package.
     Setting those values will depend on a per machine basis
   * [0e96f0e] Update Standards Version to 3.9.2. No changes required
Author: Ritesh Raj Sarraf <rrs@debian.org>
Bug-Debian: http://bugs.debian.org/545536
Bug-Debian: http://bugs.debian.org/609582
Bug-Debian: http://bugs.debian.org/628428
Bug-Debian: http://bugs.debian.org/633005
Bug-Debian: http://bugs.debian.org/636157
Bug-Debian: http://bugs.debian.org/636497

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- iscsitarget-1.4.20.2.orig/RELEASE_NOTES
+++ iscsitarget-1.4.20.2/RELEASE_NOTES
@@ -2,6 +2,34 @@
                Release Notes for iSCSI Enterprise Target
                =========================================
 
+                             May 24th, 2011
+                            Version 1.4.20.3
+                            ----------------
+
+The IET development team is pleased to announce the release of version
+1.4.20.3 of the iSCSI Enterprise Target.
+
+This release is a bugfix release. The following issues were fixed:
+- multiple compatibility updates to bring kernel support up to 2.6.39
+- fixed iSNS issue that prevented IET from registering
+- fixed re-enabling listening after max connections was exceeded
+- fixed NULL-pointer dereference due to race in UA handling
+- fixed initd scripts to reflect pid file name change
+- fixed crypto API error handling
+- fixed small memory leak in volume args buffer on BSD platforms
+- fixed max_cmd_sn not being set for the session
+- fixed issue where StatSN was being updated when a command was ignored
+- fixed connection accounting in ietd for session reinstatements
+- MaxOutStandingR2T fixed at 1 for 1.4.20 branch due to broken handling
+- fixed ipv6 address handling in SendTargets
+
+Please see the ChangeLog for a full list of bugfixes.
+
+
+               =========================================
+               Release Notes for iSCSI Enterprise Target
+               =========================================
+
                             July 14th, 2010
                             Version 1.4.20.2
                             ----------------
--- iscsitarget-1.4.20.2.orig/Makefile
+++ iscsitarget-1.4.20.2/Makefile
@@ -9,6 +9,8 @@
 
 #export KSRC := /usr/src/linux
 
+DEPMOD = depmod
+
 SUBDIRS := $(shell pwd)
 
 ifeq ($(KSRC),)
@@ -26,7 +28,7 @@ else
   endif
 endif
 
-KVER := $(shell $(CC) $(CFLAGS) -E -dM $(VERSION_FILE) | \
+KVER := $(shell $(CC) $(CFLAGS) $(LDFLAGS) -E -dM $(VERSION_FILE) | \
 	grep UTS_RELEASE | awk '{ print $$3 }' | sed 's/\"//g')
 
 KMOD := /lib/modules/$(KVER)/extra
@@ -56,6 +58,19 @@ kver_lk = $(shell [ `echo $(KVER) | egre
 # base first the earlier patch sets will not need to be modified.
 #
 
+ifeq ($(call kver_le,2,6,38),1)
+	PATCHES := $(PATCHES) compat-2.6.38.patch
+endif
+
+ifeq ($(call kver_le,2,6,37),1)
+	PATCHES := $(PATCHES) compat-2.6.36-2.6.37.patch
+endif
+
+# Compatibility patch for kernels > 2.6.32 <= 2.6.35
+ifeq ($(call kver_le,2,6,35),1)
+	PATCHES := $(PATCHES) compat-2.6.33-2.6.35.patch
+endif
+
 # Compatibility patch for kernels <= 2.6.32
 ifeq ($(call kver_le,2,6,32),1)
 	PATCHES := $(PATCHES) compat-2.6.32.patch
@@ -210,9 +225,9 @@ unpatch:
 depmod:
 	@echo "Running depmod"
 	@if [ x$(DESTDIR) != x -o x$(INSTALL_MOD_PATH) != x ]; then \
-		depmod -aq -b $(DESTDIR)$(INSTALL_MOD_PATH) $(KVER); \
+		$(DEPMOD) -aq -b $(DESTDIR)$(INSTALL_MOD_PATH) $(KVER); \
 	else \
-		depmod -aq $(KVER); \
+		$(DEPMOD) -aq $(KVER); \
 	fi
 
 install-files: install-usr install-etc install-doc install-kernel
@@ -231,7 +246,7 @@ install-kernel: kernel/iscsi_trgt.ko
 				-execdir mv \{\} \{\}.orig \;; \
 		fi \
 	fi
-	@install -vD kernel/iscsi_trgt.ko \
+	@install -vD -m 644 kernel/iscsi_trgt.ko \
 		$(DESTDIR)$(INSTALL_MOD_PATH)$(KMOD)/iscsi/iscsi_trgt.ko
 
 install-usr: usr/ietd usr/ietadm
--- iscsitarget-1.4.20.2.orig/dkms.conf
+++ iscsitarget-1.4.20.2/dkms.conf
@@ -3,7 +3,7 @@
 #
 
 PACKAGE_NAME="iscsitarget"
-PACKAGE_VERSION="1.4.20.2"
+PACKAGE_VERSION="1.4.20.3"
 MOD_PATH=${dkms_tree}/${PACKAGE_NAME}/${PACKAGE_VERSION}
 
 BUILT_MODULE_NAME="iscsi_trgt"
@@ -20,42 +20,48 @@ AUTOINSTALL="yes"
 # Patches newest - oldest, distro spec at bottom
 #
 
-PATCH[0]="compat-2.6.32.patch"
-PATCH_MATCH[0]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32)"
+PATCH[0]="compat-2.6.36-2.6.37.patch"
+PATCH_MATCH[0]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37)"
 
-PATCH[1]="compat-2.6.31.patch"
-PATCH_MATCH[1]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)"
+PATCH[1]="compat-2.6.33-2.6.35.patch"
+PATCH_MATCH[1]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35)"
 
-PATCH[2]="compat-2.6.30.patch"
-PATCH_MATCH[2]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30)"
+PATCH[2]="compat-2.6.32.patch"
+PATCH_MATCH[2]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32)"
 
-PATCH[3]="compat-2.6.29.patch"
-PATCH_MATCH[3]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29)"
+PATCH[3]="compat-2.6.31.patch"
+PATCH_MATCH[3]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)"
 
-PATCH[4]="compat-2.6.28.patch"
-PATCH_MATCH[4]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28)"
+PATCH[4]="compat-2.6.30.patch"
+PATCH_MATCH[4]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30)"
 
-PATCH[5]="compat-2.6.25-2.6.27.patch"
-PATCH_MATCH[5]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27)"
+PATCH[5]="compat-2.6.29.patch"
+PATCH_MATCH[5]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29)"
 
-PATCH[6]="compat-2.6.24.patch"
-PATCH_MATCH[6]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24)"
+PATCH[6]="compat-2.6.28.patch"
+PATCH_MATCH[6]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28)"
 
-PATCH[7]="compat-2.6.23.patch"
-PATCH_MATCH[7]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23)"
+PATCH[7]="compat-2.6.25-2.6.27.patch"
+PATCH_MATCH[7]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27)"
 
-PATCH[8]="compat-2.6.22.patch"
-PATCH_MATCH[8]="2\.6\.(9|14|15|16|17|18|19|20|21|22)"
+PATCH[8]="compat-2.6.24.patch"
+PATCH_MATCH[8]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24)"
 
-PATCH[9]="compat-2.6.19-2.6.21.patch"
-PATCH_MATCH[9]="2\.6\.(9|14|15|16|17|18|19|20|21)"
+PATCH[9]="compat-2.6.23.patch"
+PATCH_MATCH[9]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23)"
 
-PATCH[10]="compat-2.6.14-2.6.18.patch"
-PATCH_MATCH[10]="2\.6\.(9|14|15|16|17|18)"
+PATCH[10]="compat-2.6.22.patch"
+PATCH_MATCH[10]="2\.6\.(9|14|15|16|17|18|19|20|21|22)"
 
-PATCH[11]="compat-sles10sp2.patch"
-PATCH_MATCH[11]="2\.6\.16\.60-.*"
+PATCH[11]="compat-2.6.19-2.6.21.patch"
+PATCH_MATCH[11]="2\.6\.(9|14|15|16|17|18|19|20|21)"
 
-PATCH[12]="compat-rhel4.patch"
-PATCH_MATCH[12]="2\.6\.9-.*\.(el|plus\.c4)"
+PATCH[12]="compat-2.6.14-2.6.18.patch"
+PATCH_MATCH[12]="2\.6\.(9|14|15|16|17|18)"
+
+PATCH[13]="compat-sles10sp2.patch"
+PATCH_MATCH[13]="2\.6\.16\.60-.*"
+
+PATCH[14]="compat-rhel4.patch"
+PATCH_MATCH[14]="2\.6\.9-.*\.(el|plus\.c4)"
 
--- iscsitarget-1.4.20.2.orig/iscsitarget.spec
+++ iscsitarget-1.4.20.2/iscsitarget.spec
@@ -3,7 +3,7 @@
 ##
 
 ## IET Release
-%define iet_version 1.4.20.2
+%define iet_version 1.4.20.3
 
 ## Package Revision
 %define revision 1
@@ -113,7 +113,7 @@ Requires: %{name}-kmod = %{version}
 
 ## Build Requirements
 BuildRequires: kernel >= 2.6
-BuildRequires: gcc, make, patch, binutils, /usr/bin/install, openssl-devel
+BuildRequires: gcc, make, patch, binutils, /usr/bin/install
 %if %is_suse
 BuildRequires: kernel-source = %{kver}
 %else
@@ -408,6 +408,9 @@ fi
 
 
 %changelog
+* Mon Jan 10 2011 Ross Walker <rswwalker at gmail dot com> - 1.4.20.3
+- removed stray RPM build dependency on openssl
+
 * Tue May 11 2010 Ross Walker <rswwalker at gmail dot com> - 1.4.20.2
 - fixed recursive KERNELSRC define problem on SLES
 - updated SVN building to handle tagged builds
--- iscsitarget-1.4.20.2.orig/ChangeLog
+++ iscsitarget-1.4.20.2/ChangeLog
@@ -1,10 +1,63 @@
+Summary of changes from v1.4.20.2 to v1.4.20.3
+=================================
+Arne Redlich
+  o Fixed iSNS initialization issue, thanks to majianpeng@gmail.com
+  o The NIPQUAD macro has been removed, instead "%pI4" is used
+  o Converted semaphores to mutexes
+  o Fixed printing IPv4 addresses in /proc/net/iet/session for kernels >= 2.6.33
+  o Fixed block device handling for kernels >= 2.6.38
+  o 2.6.39 compile fix
+  o Fixed oops after write attempts to readonly LUs
+
+Chris Siebenmann, Wido den Hollander
+  o 2.6.36 compile fix
+
+Craig
+  o Makefile respects LDFLAGS
+
+Jason Zhang
+  o Fixed re-enabling listening after max connections was exceeded
+  o Fix NULL-pointer dereference due to race in UA handling
+
+Martin Hicks
+  o Added variable for depmod
+  o Don't install kernel module executable
+  o Don't use bash for initd script
+
+Ross Walker
+  o Updated initd scripts to reflect PID file name change
+  o Removed stray RPM build dependency on openssl from spec file
+  o Fixed crypto API error handling (ERR_PTR instead of a NULL)
+  o Fixed small memory leak in volume args buffer on BSD
+  o Fixed io context handling on kernels >= 2.6.25
+  o Fixed io context handling on RHEL 5.6
+  o Fixed max_cmd_sn not being set for the session
+  o Fixed issue where StatSN was being updated when a command was ignored
+  o Fixed connection accounting in ietd for session reinstatements
+  o MaxOutStandingR2T fixed at 1 for 1.4.20 branch due to broken handling
+  o Stripped zone id off ipv6 addresses in SendTargets
+  o Time2Retain fixed at 0 since it isn't implemented
+  o Fixed Expected Data Transfer Length handling
+  o Fixed session establishment for initiators foregoing security negotiation
+  o Fixed infinite loop on digest errors
+  o Fixed session shutdown in case of initiators sending data segments thar are too large
+
 Summary of changes from v1.4.20.1 to v1.4.20.2
 =================================
 Arne Redlich
+  o adapt backward compat mechanism in Makefile to kernels >= 2.6.33
   o uninitialized data fixes pointed out by valgrind
   o fix invalid read in iSNS code pointed out by valgrind
+  o Fixed iSNS initialization issue
+  o The NIPQUAD macro has been removed, instead "%pI4" is used
+  o Converted semaphores to mutexes
+  o Fixed printing IPv4 addresses in /proc/net/iet/session for kernels >= 2.6.33
+  o Fixed re-enabling listening after max connections was exceeded
+  o Fix NULL-pointer dereference due to race in UA handling
+  o Fixed block device handling for kernels >= 2.6.38
 
 Ross Walker
+  o restore SCSI SN behaviour of IET < 1.4.20 (VMWare compatibility)
   o check buffer boundaries in iSNS code (CVE-2010-2221)
   o fix memleak in iSNS ACL code
   o clean up iSCSI login response error handling
@@ -12,15 +65,24 @@ Ross Walker
   o fix soft lockup during UA allocation
   o change DISTDIR to DESTDIR
   o avoid deletion of targets with active sessions
-  o byte swap fix in MD5 / SHA1 code (thanks to Harshal Shete for testing on PPC)
-
-Summary of changes from v1.4.20 to v1.4.20.1
-=================================
-Arne Redlich
-  o adapt backward compat mechanism in Makefile to kernels >= 2.6.33
+  o byte swap fix in MD5 / SHA1 code
+  o Updated initd scripts to reflect PID file name change
+  o Removed stray RPM build dependency on openssl from spec file
+  o Fixed crypto API error handling (ERR_PTR instead of a NULL)
+  o Fixed small memory leak in volume args buffer on BSD
+  o Fixed io context handling on kernels >= 2.6.25
+  o Fixed max_cmd_sn not being set for the session
+  o Fixed issue where StatSN was being updated when a command was ignored
+  o Fixed connection accounting in ietd for session reinstatements
+  o Fixed MaxOutStandingR2T handling
+  o Stripped zone id off ipv6 addresses in SendTargets
+  o Time2Wait and Time2Retain fixed at 0 since these aren't implemented
 
-Ross Walker
-  o restore SCSI SN behaviour of IET < 1.4.20 (VMWare compatibility)
+Martin Hicks
+  o Makefile respects LDFLAGS
+  o Added variable for depmod
+  o Don't install kernel module executable
+  o Don't use bash for initd script
 
 Summary of changes from v1.4.19 to v1.4.20
 =================================
--- iscsitarget-1.4.20.2.orig/include/iet_u.h
+++ iscsitarget-1.4.20.2/include/iet_u.h
@@ -1,7 +1,7 @@
 #ifndef _IET_U_H
 #define _IET_U_H
 
-#define IET_VERSION_STRING	"1.4.20.2"
+#define IET_VERSION_STRING	"1.4.20.3"
 
 /* The maximum length of 223 bytes in the RFC. */
 #define ISCSI_NAME_LEN	256
--- iscsitarget-1.4.20.2.orig/kernel/nthread.c
+++ iscsitarget-1.4.20.2/kernel/nthread.c
@@ -242,7 +242,7 @@ next_state:
 	case RX_CHECK_HDIGEST:
 		rx_hdigest(conn, RX_INIT_DATA);
 		if (conn->read_state != RX_INIT_DATA)
-			break;
+			return -EIO;
 	case RX_INIT_DATA:
 		cmnd_rx_start(cmnd);
 		conn->read_state = cmnd->pdu.datasize ? RX_DATA : RX_END;
@@ -261,6 +261,8 @@ next_state:
 			break;
 	case RX_CHECK_DDIGEST:
 		rx_ddigest(conn, RX_END);
+		if (conn->read_state != RX_END)
+			return -EIO;
 		break;
 	default:
 		eprintk("%d %d %x\n", res, conn->read_state, cmnd_opcode(cmnd));
--- iscsitarget-1.4.20.2.orig/kernel/tio.c
+++ iscsitarget-1.4.20.2/kernel/tio.c
@@ -91,6 +91,8 @@ int tio_read(struct iet_volume *lu, stru
 {
 	struct iotype *iot = lu->iotype;
 	assert(iot);
+	if (!tio->size)
+		return 0;
 	return iot->make_request ? iot->make_request(lu, tio, READ) : 0;
 }
 
@@ -98,6 +100,8 @@ int tio_write(struct iet_volume *lu, str
 {
 	struct iotype *iot = lu->iotype;
 	assert(iot);
+	if (!tio->size)
+		return 0;
 	return iot->make_request ? iot->make_request(lu, tio, WRITE) : 0;
 }
 
--- iscsitarget-1.4.20.2.orig/kernel/param.c
+++ iscsitarget-1.4.20.2/kernel/param.c
@@ -51,6 +51,8 @@ static void sess_param_check(struct iscs
 	CHECK_PARAM(info, iparam, error_recovery_level, 0, 0);
 	CHECK_PARAM(info, iparam, data_pdu_inorder, 1, 1);
 	CHECK_PARAM(info, iparam, data_sequence_inorder, 1, 1);
+	CHECK_PARAM(info, iparam, max_outstanding_r2t, 1, 1);
+	CHECK_PARAM(info, iparam, default_retain_time, 0, 0);
 
 	digest_alg_available(&iparam[key_header_digest]);
 	digest_alg_available(&iparam[key_data_digest]);
--- iscsitarget-1.4.20.2.orig/kernel/iotype.c
+++ iscsitarget-1.4.20.2/kernel/iotype.c
@@ -9,7 +9,7 @@
 #include "iscsi_dbg.h"
 
 static LIST_HEAD(iotypes);
-static rwlock_t iotypes_lock = RW_LOCK_UNLOCKED;
+static DEFINE_RWLOCK(iotypes_lock);
 
 static struct iotype *find_iotype(const char *name)
 {
--- iscsitarget-1.4.20.2.orig/kernel/iscsi.c
+++ iscsitarget-1.4.20.2/kernel/iscsi.c
@@ -384,13 +384,29 @@ void send_scsi_rsp(struct iscsi_cmnd *re
 void send_data_rsp(struct iscsi_cmnd *req, void (*func)(struct iscsi_cmnd *))
 {
 	struct iscsi_cmnd *rsp;
+	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	u32 size;
 
 	func(req);
 
-	if (req->status == SAM_STAT_GOOD)
+	assert(req->tio);
+
+	size = min(req->tio->size, cmnd_read_size(req));
+
+	if (req->status == SAM_STAT_GOOD && size)
 		do_send_data_rsp(req);
 	else {
 		rsp = create_scsi_rsp(req);
+		rsp_hdr = (struct iscsi_scsi_rsp_hdr *) &rsp->pdu.bhs;
+		if ((size = cmnd_read_size(req)) > req->tio->size) {
+			rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+			rsp_hdr->residual_count =
+					cpu_to_be32(size - req->tio->size);
+		} else if (size < req->tio->size) {
+			rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_OVERFLOW;
+			rsp_hdr->residual_count =
+					cpu_to_be32(req->tio->size - size);
+		}
 		iscsi_cmnd_init_write(rsp);
 	}
 }
@@ -510,10 +526,13 @@ static void cmnd_set_sn(struct iscsi_cmn
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_session *sess = conn->session;
 
+	sess->max_cmd_sn = sess->exp_cmd_sn + sess->max_queued_cmnds;
+
 	if (set_stat_sn)
 		cmnd->pdu.bhs.sn = cpu_to_be32(conn->stat_sn++);
+
 	cmnd->pdu.bhs.exp_sn = cpu_to_be32(sess->exp_cmd_sn);
-	cmnd->pdu.bhs.max_sn = cpu_to_be32(sess->exp_cmd_sn + sess->max_queued_cmnds);
+	cmnd->pdu.bhs.max_sn = cpu_to_be32(sess->max_cmd_sn);
 }
 
 static void update_stat_sn(struct iscsi_cmnd *cmnd)
@@ -619,8 +638,9 @@ static int cmnd_insert_hash(struct iscsi
 
 	err = cmnd_insert_hash_ttt(cmnd, ISCSI_RESERVED_TAG);
 	if (!err) {
-		update_stat_sn(cmnd);
 		err = check_cmd_sn(cmnd);
+		if (!err)
+			update_stat_sn(cmnd);
 	} else if (!cmnd_immediate(cmnd))
 		set_cmnd_tmfabort(cmnd);
 
@@ -691,6 +711,9 @@ static int cmnd_recv_pdu(struct iscsi_co
 	dprintk(D_GENERIC, "%p %u,%u\n", tio, offset, size);
 	offset += tio->offset;
 
+	if (!size)
+		return 0;
+
 	if (!(offset < tio->offset + tio->size) ||
 	    !(offset + size <= tio->offset + tio->size)) {
 		eprintk("%u %u %u %u", offset, size, tio->offset, tio->size);
@@ -876,10 +899,10 @@ static int nop_out_start(struct iscsi_co
 	if (cmnd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		if (!cmnd_immediate(cmnd))
 			eprintk("%s\n", "initiator bug!");
-		update_stat_sn(cmnd);
 		err = check_cmd_sn(cmnd);
 		if (err)
 			goto out;
+		update_stat_sn(cmnd);
 	} else if ((err = cmnd_insert_hash(cmnd)) < 0) {
 		eprintk("ignore this request %x\n", cmnd_itt(cmnd));
 		goto out;
@@ -1012,12 +1035,6 @@ static void scsi_cmnd_start(struct iscsi
 		req->is_unsolicited_data = !(req_hdr->flags & ISCSI_CMD_FINAL);
 		req->target_task_tag = get_next_ttt(conn->session);
 
-		if (LUReadonly(req->lun)) {
-			create_sense_rsp(req, DATA_PROTECT, 0x27, 0x0);
-			cmnd_skip_data(req);
-			break;
-		}
-
 		if (!param->immediate_data && req->pdu.datasize)
 			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
 
@@ -1798,11 +1815,8 @@ static int check_segment_length(struct i
 	if (cmnd->pdu.datasize > param->max_recv_data_length) {
 		eprintk("data too long %x %u %u\n", cmnd_itt(cmnd),
 			cmnd->pdu.datasize, param->max_recv_data_length);
-
-		if (get_pgcnt(cmnd->pdu.datasize, 0) > ISCSI_CONN_IOV_MAX) {
-			conn_close(conn);
-			return -EINVAL;
-		}
+		conn_close(conn);
+		return -EINVAL;
 	}
 
 	return 0;
--- iscsitarget-1.4.20.2.orig/kernel/block-io.c
+++ iscsitarget-1.4.20.2/kernel/block-io.c
@@ -56,6 +56,7 @@ blockio_make_request(struct iet_volume *
 	struct request_queue *bdev_q = bdev_get_queue(bio_data->bdev);
 	struct tio_work *tio_work;
 	struct bio *tio_bio = NULL, *bio = NULL, *biotail = NULL;
+	struct blk_plug plug;
 
 	u32 offset = tio->offset;
 	u32 size = tio->size;
@@ -118,6 +119,8 @@ blockio_make_request(struct iet_volume *
 		}
 	}
 
+	blk_start_plug(&plug);
+
 	/* Walk the list, submitting bios 1 by 1 */
 	while (tio_bio) {
 		bio = tio_bio;
@@ -127,8 +130,7 @@ blockio_make_request(struct iet_volume *
 		submit_bio(rw, bio);
 	}
 
-	if (bdev_q && bdev_q->unplug_fn)
-		bdev_q->unplug_fn(bdev_q);
+	blk_finish_plug(&plug);
 
 	wait_for_completion(&tio_work->tio_complete);
 
@@ -155,14 +157,14 @@ blockio_open_path(struct iet_volume *vol
 {
 	struct blockio_data *bio_data = volume->private;
 	struct block_device *bdev;
-	int flags = FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
+	int flags = FMODE_EXCL | FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
 	int err = 0;
 
 	bio_data->path = kstrdup(path, GFP_KERNEL);
 	if (!bio_data->path)
 		return -ENOMEM;
 
-	bdev = open_bdev_exclusive(path, flags, THIS_MODULE);
+	bdev = blkdev_get_by_path(path, flags, THIS_MODULE);
 	if (IS_ERR(bdev)) {
 		err = PTR_ERR(bdev);
 		eprintk("Can't open device %s, error %d\n", path, err);
@@ -250,10 +252,10 @@ static void
 blockio_detach(struct iet_volume *volume)
 {
 	struct blockio_data *bio_data = volume->private;
-	int flags = FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
+	int flags = FMODE_EXCL | FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
 
 	if (bio_data->bdev)
-		close_bdev_exclusive(bio_data->bdev, flags);
+		blkdev_put(bio_data->bdev, flags);
 	kfree(bio_data->path);
 
 	kfree(volume->private);
--- iscsitarget-1.4.20.2.orig/kernel/target.c
+++ iscsitarget-1.4.20.2/kernel/target.c
@@ -4,6 +4,8 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <linux/mutex.h>
+
 #include "iscsi.h"
 #include "digest.h"
 #include "iscsi_dbg.h"
@@ -11,7 +13,7 @@
 #define	MAX_NR_TARGETS	(1UL << 30)
 
 static LIST_HEAD(target_list);
-static DECLARE_MUTEX(target_list_sem);
+static DEFINE_MUTEX(target_list_mutex);
 static u32 next_target_id;
 static u32 nr_targets;
 
@@ -24,7 +26,7 @@ static struct iscsi_sess_param default_s
 	.max_burst_length = 262144,
 	.first_burst_length = 65536,
 	.default_wait_time = 2,
-	.default_retain_time = 20,
+	.default_retain_time = 0,
 	.max_outstanding_r2t = 1,
 	.data_pdu_inorder = 1,
 	.data_sequence_inorder = 1,
@@ -48,16 +50,16 @@ inline int target_lock(struct iscsi_targ
 	int err = 0;
 
 	if (interruptible)
-		err = down_interruptible(&target->target_sem);
+		err = mutex_lock_interruptible(&target->target_mutex);
 	else
-		down(&target->target_sem);
+		mutex_lock(&target->target_mutex);
 
 	return err;
 }
 
 inline void target_unlock(struct iscsi_target *target)
 {
-	up(&target->target_sem);
+	mutex_unlock(&target->target_mutex);
 }
 
 static struct iscsi_target *__target_lookup_by_id(u32 id)
@@ -86,9 +88,9 @@ struct iscsi_target *target_lookup_by_id
 {
 	struct iscsi_target *target;
 
-	down(&target_list_sem);
+	mutex_lock(&target_list_mutex);
 	target = __target_lookup_by_id(id);
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 
 	return target;
 }
@@ -157,7 +159,7 @@ static int iscsi_target_create(struct ta
 
 	strncpy(target->name, name, sizeof(target->name) - 1);
 
-	init_MUTEX(&target->target_sem);
+	mutex_init(&target->target_mutex);
 	spin_lock_init(&target->session_list_lock);
 
 	INIT_LIST_HEAD(&target->session_list);
@@ -195,7 +197,7 @@ int target_add(struct target_info *info)
 	u32 tid = info->tid;
 	int err;
 
-	err = down_interruptible(&target_list_sem);
+	err = mutex_lock_interruptible(&target_list_mutex);
 	if (err < 0)
 		return err;
 
@@ -204,7 +206,7 @@ int target_add(struct target_info *info)
 		goto out;
 	}
 
-	if (__target_lookup_by_name(info->name) || 
+	if (__target_lookup_by_name(info->name) ||
 			(tid && __target_lookup_by_id(tid))) {
 		err = -EEXIST;
 		goto out;
@@ -223,7 +225,7 @@ int target_add(struct target_info *info)
 	if (!err)
 		nr_targets++;
 out:
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 
 	return err;
 }
@@ -232,8 +234,6 @@ static void target_destroy(struct iscsi_
 {
 	dprintk(D_SETUP, "%u\n", target->tid);
 
-	target_thread_stop(target);
-
 	while (!list_empty(&target->volumes)) {
 		struct iet_volume *volume;
 		volume = list_entry(target->volumes.next, struct iet_volume, list);
@@ -241,6 +241,8 @@ static void target_destroy(struct iscsi_
 		iscsi_volume_destroy(volume);
 	}
 
+	target_thread_stop(target);
+
 	if (!worker_thread_pool)
 		kfree(target->wthread_info);
 	kfree(target);
@@ -248,7 +250,7 @@ static void target_destroy(struct iscsi_
 	module_put(THIS_MODULE);
 }
 
-/* @locking: target_list_sem must be locked */
+/* @locking: target_list_mutex must be locked */
 static int __target_del(struct iscsi_target *target)
 {
 	int err;
@@ -283,7 +285,7 @@ int target_del(u32 id)
 	struct iscsi_target *target;
 	int err;
 
-	err = down_interruptible(&target_list_sem);
+	err = mutex_lock_interruptible(&target_list_mutex);
 	if (err < 0)
 		return err;
 
@@ -295,7 +297,7 @@ int target_del(u32 id)
 
 	err = __target_del(target);
 out:
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 
 	return err;
 }
@@ -305,7 +307,7 @@ void target_del_all(void)
 	struct iscsi_target *target, *tmp;
 	int err;
 
-	down(&target_list_sem);
+	mutex_lock(&target_list_mutex);
 
 	if (!list_empty(&target_list))
 		iprintk("Removing all connections, sessions and targets\n");
@@ -319,7 +321,7 @@ void target_del_all(void)
 
 	next_target_id = 0;
 
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 }
 
 static void *iet_seq_start(struct seq_file *m, loff_t *pos)
@@ -327,7 +329,7 @@ static void *iet_seq_start(struct seq_fi
 	int err;
 
 	/* are you sure this is to be interruptible? */
-	err = down_interruptible(&target_list_sem);
+	err = mutex_lock_interruptible(&target_list_mutex);
 	if (err < 0)
 		return ERR_PTR(err);
 
@@ -341,7 +343,7 @@ static void *iet_seq_next(struct seq_fil
 
 static void iet_seq_stop(struct seq_file *m, void *v)
 {
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 }
 
 static int iet_seq_show(struct seq_file *m, void *p)
--- iscsitarget-1.4.20.2.orig/kernel/config.c
+++ iscsitarget-1.4.20.2/kernel/config.c
@@ -9,7 +9,7 @@
 #include "iscsi.h"
 #include "iscsi_dbg.h"
 
-static DECLARE_MUTEX(ioctl_sem);
+static DEFINE_MUTEX(ioctl_mutex);
 
 struct proc_entries {
 	const char *name;
@@ -258,7 +258,7 @@ static long ioctl(struct file *file, uns
 	long err;
 	u32 id;
 
-	err = down_interruptible(&ioctl_sem);
+	err = mutex_lock_interruptible(&ioctl_mutex);
 	if (err < 0)
 		return err;
 
@@ -339,7 +339,7 @@ static long ioctl(struct file *file, uns
 
 	target_unlock(target);
 done:
-	up(&ioctl_sem);
+	mutex_unlock(&ioctl_mutex);
 
 	return err;
 }
@@ -347,9 +347,9 @@ done:
 static int release(struct inode *i __attribute__((unused)),
 		   struct file *f __attribute__((unused)))
 {
-	down(&ioctl_sem);
+	mutex_lock(&ioctl_mutex);
 	target_del_all();
-	up(&ioctl_sem);
+	mutex_unlock(&ioctl_mutex);
 
 	return 0;
 }
--- iscsitarget-1.4.20.2.orig/kernel/volume.c
+++ iscsitarget-1.4.20.2/kernel/volume.c
@@ -6,6 +6,7 @@
 
 #include <linux/types.h>
 #include <linux/parser.h>
+#include <linux/blkdev.h>
 
 #include "iscsi.h"
 #include "iscsi_dbg.h"
@@ -87,7 +88,7 @@ static void gen_scsiid(struct iet_volume
 	hash.tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);
 	hash.flags = 0;
 
-	if (hash.tfm) {
+	if (!IS_ERR(hash.tfm)) {
 		struct scatterlist sg[2];
 		unsigned int nbytes = 0;
 
@@ -111,8 +112,7 @@ static void gen_scsiid(struct iet_volume
 						sizeof(volume->target->tid));
 		memcpy(volume->scsi_id + sizeof(volume->target->tid),
 					&volume->lun, sizeof(volume->lun));
-	}	
-
+	}
 }
 
 static int parse_volume_params(struct iet_volume *volume, char *params)
@@ -120,10 +120,12 @@ static int parse_volume_params(struct ie
 	int err = 0;
 	unsigned blk_sz;
 	substring_t args[MAX_OPT_ARGS];
-	char *p, *argp = NULL, *buf = (char *) get_zeroed_page(GFP_USER);
+	char *p, *argp = NULL, *bp, *buf = (char *) get_zeroed_page(GFP_USER);
 
 	if (!buf)
 		return -ENOMEM;
+	else
+		bp = buf;
 
 	strncpy(buf, params, PAGE_CACHE_SIZE);
 
@@ -203,7 +205,7 @@ static int parse_volume_params(struct ie
 		err = -EINVAL;
 	}
 
-	free_page((unsigned long) buf);
+	free_page((unsigned long) bp);
 
 	return err;
 }
--- iscsitarget-1.4.20.2.orig/kernel/target_disk.c
+++ iscsitarget-1.4.20.2/kernel/target_disk.c
@@ -247,7 +247,7 @@ static void build_inquiry_response(struc
 			data[7] = len;
 			if (cmnd->lun) { /* We need this ? */
 				memset(data + 8, 0x00, 8);
-				memcpy(data + 8, VENDOR_ID, 
+				memcpy(data + 8, VENDOR_ID,
 					min_t(size_t, strlen(VENDOR_ID), 8));
 				memcpy(data + 16, cmnd->lun->scsi_id,
 								SCSI_ID_LEN);
@@ -399,19 +399,29 @@ static void build_write_response(struct
 	assert(cmnd->lun);
 
 	list_del_init(&cmnd->list);
-	err = tio_write(cmnd->lun, tio);
-	if (!err && !LUWCache(cmnd->lun))
-		err = tio_sync(cmnd->lun, tio);
 
-	if (err)
-		/* Medium Error/Write Fault */
-		iscsi_cmnd_set_sense(cmnd, MEDIUM_ERROR, 0x03, 0x0);
+	if (LUReadonly(cmnd->lun))
+		iscsi_cmnd_set_sense(cmnd, DATA_PROTECT, 0x27, 0x0);
+	else {
+		err = tio_write(cmnd->lun, tio);
+		if (!err && !LUWCache(cmnd->lun))
+			err = tio_sync(cmnd->lun, tio);
+
+		if (err)
+			/* Medium Error/Write Fault */
+			iscsi_cmnd_set_sense(cmnd, MEDIUM_ERROR, 0x03,
+					     0x0);
+	}
 }
 
 static void build_sync_cache_response(struct iscsi_cmnd *cmnd)
 {
+	int err;
+
 	assert(cmnd->lun);
-	if (tio_sync(cmnd->lun, NULL))
+
+	err = tio_sync(cmnd->lun, NULL);
+	if (err)
 		/* Medium Error/Write Fault */
 		iscsi_cmnd_set_sense(cmnd, MEDIUM_ERROR, 0x03, 0x0);
 }
@@ -477,11 +487,17 @@ static int disk_check_ua(struct iscsi_cm
 			break;
 		default:
 			ua = ua_get_first(cmnd->conn->session, cmnd->lun->lun);
-			iscsi_cmnd_set_sense(cmnd, UNIT_ATTENTION, ua->asc,
-					     ua->ascq);
-			ua_free(ua);
-			send_scsi_rsp(cmnd, build_generic_response);
-			return 1;
+			/*
+			 * potential race: another wthread could've reported it
+			 * in the meantime
+			 */
+			if (ua) {
+				iscsi_cmnd_set_sense(cmnd, UNIT_ATTENTION, ua->asc,
+						     ua->ascq);
+				ua_free(ua);
+				send_scsi_rsp(cmnd, build_generic_response);
+				return 1;
+			}
 		}
 	}
 	return 0;
--- iscsitarget-1.4.20.2.orig/kernel/conn.c
+++ iscsitarget-1.4.20.2/kernel/conn.c
@@ -44,7 +44,7 @@ void conn_info_show(struct seq_file *seq
 		switch (sk->sk_family) {
 		case AF_INET:
 			snprintf(buf, sizeof(buf),
-				 "%u.%u.%u.%u", NIPQUAD(inet_sk(sk)->inet_daddr));
+				 "%pI4", &inet_sk(sk)->inet_daddr);
 			break;
 		case AF_INET6:
 			snprintf(buf, sizeof(buf), "[%pI6]",
@@ -241,8 +241,6 @@ int conn_add(struct iscsi_session *sessi
 		conn_close(conn);
 
 	err = iet_conn_alloc(session, info);
-	if (!err && conn)
-		err = -EEXIST;
 
 	return err;
 }
--- iscsitarget-1.4.20.2.orig/kernel/iscsi.h
+++ iscsitarget-1.4.20.2/kernel/iscsi.h
@@ -130,7 +130,7 @@ struct iscsi_target {
 	/* Points either to own list or global pool */
 	struct worker_thread_info * wthread_info;
 
-	struct semaphore target_sem;
+	struct mutex target_mutex;
 };
 
 struct iscsi_queue {
--- iscsitarget-1.4.20.2.orig/kernel/wthread.c
+++ iscsitarget-1.4.20.2/kernel/wthread.c
@@ -67,14 +67,13 @@ static int worker_thread(void *arg)
 	struct iscsi_conn *conn;
 	DECLARE_WAITQUEUE(wait, current);
 
-	get_io_context(GFP_KERNEL, -1);
-
-	if (!current->io_context)
-		eprintk("%s\n", "Failed to get IO context");
-	else if (info->wthread_ioc)
-		copy_io_context(&current->io_context, &info->wthread_ioc);
-	else
-		info->wthread_ioc = current->io_context;
+	if (info->wthread_ioc &&
+	    atomic_long_inc_not_zero(&info->wthread_ioc->refcount)) {
+		put_io_context(current->io_context);
+		current->io_context = info->wthread_ioc;
+		atomic_inc(&info->wthread_ioc->nr_tasks);
+	} else
+		info->wthread_ioc = get_io_context(GFP_KERNEL, -1);
 
 	add_wait_queue(&info->wthread_sleep, &wait);
 
@@ -101,12 +100,14 @@ static int worker_thread(void *arg)
 	remove_wait_queue(&info->wthread_sleep, &wait);
 
 	if (current->io_context) {
-		struct io_context *ioc = current->io_context;
+		struct io_context *ioc;
 
 		task_lock(current);
+		ioc = current->io_context;
 		current->io_context = NULL;
 		task_unlock(current);
 
+		atomic_dec(&ioc->nr_tasks);
 		put_io_context(ioc);
 	}
 
--- iscsitarget-1.4.20.2.orig/patches/compat-2.6.19-2.6.21.patch
+++ iscsitarget-1.4.20.2/patches/compat-2.6.19-2.6.21.patch
@@ -16,7 +16,7 @@ Index: kernel/iscsi.c
 ===================================================================
 --- 1/kernel/iscsi.c	(working copy)
 +++ 2/kernel/iscsi.c	(revision 137)
-@@ -1925,7 +1925,8 @@ static int iscsi_init(void)
+@@ -1929,7 +1929,8 @@ static int iscsi_init(void)
  	if ((err = event_init()) < 0)
  		goto err;
 
--- iscsitarget-1.4.20.2.orig/patches/compat-2.6.14-2.6.18.patch
+++ iscsitarget-1.4.20.2/patches/compat-2.6.14-2.6.18.patch
@@ -2,7 +2,7 @@ Index: kernel/iscsi.h
 ===================================================================
 --- 1/kernel/iscsi.h	(revision 105)
 +++ 2/kernel/iscsi.h	(working copy)
-@@ -261,8 +261,8 @@ struct iscsi_conn {
+@@ -262,8 +262,8 @@ struct iscsi_conn {
  	u32 write_offset;
  	int write_state;
  
@@ -199,17 +199,6 @@ Index: kernel/tio.c
  
  struct tio *tio_alloc(int count)
  {
---- context/kernel/wthread.c	2010-01-25 11:27:57.000000000 -0500
-+++ context/kernel/wthread.c.18	2010-01-25 11:25:43.000000000 -0500
-@@ -67,7 +67,7 @@
- 	struct iscsi_conn *conn;
- 	DECLARE_WAITQUEUE(wait, current);
- 
--	get_io_context(GFP_KERNEL, -1);
-+	get_io_context(GFP_KERNEL);
- 
- 	if (!current->io_context)
- 		eprintk("%s\n", "Failed to get IO context");
 --- param/kernel/volume.c	2010-04-08 18:05:38.000000000 -0400
 +++ param/kernel/volume.c.18	2010-04-08 18:05:38.000000000 -0400
 @@ -84,28 +84,26 @@ static int set_scsisn(struct iet_volume 
@@ -223,7 +212,7 @@ Index: kernel/tio.c
 -	hash.flags = 0;
 +	tfm = crypto_alloc_tfm("md5", 0);
  
--	if (hash.tfm) {
+-	if (!IS_ERR(hash.tfm)) {
 +	if (tfm) {
  		struct scatterlist sg[2];
 -		unsigned int nbytes = 0;
@@ -250,3 +239,14 @@ Index: kernel/tio.c
  	} else {
  		/* If no MD5 available set ID to TID and LUN */
  		memcpy(volume->scsi_id, &volume->target->tid,
+--- ioc/kernel/wthread.c	2011-01-13 15:12:47.000000000 -0500
++++ ioc/kernel/wthread.c	2011-01-13 15:13:17.000000000 -0500
+@@ -72,7 +72,7 @@ static int worker_thread(void *arg)
+ 		put_io_context(current->io_context);
+ 		current->io_context = info->wthread_ioc;
+ 	} else
+-		info->wthread_ioc = get_io_context(GFP_KERNEL, -1);
++		info->wthread_ioc = get_io_context(GFP_KERNEL);
+ 
+ 	add_wait_queue(&info->wthread_sleep, &wait);
+ 
--- iscsitarget-1.4.20.2.orig/patches/compat-2.6.24.patch
+++ iscsitarget-1.4.20.2/patches/compat-2.6.24.patch
@@ -10,3 +10,21 @@ index 240404d..e45ed67 100644
 +	if (nl)
 +		sock_release(nl->sk_socket);
  }
+--- ioc/kernel/wthread.c	2011-01-13 15:10:19.000000000 -0500
++++ ioc/kernel/wthread.c	2011-01-13 15:12:47.000000000 -0500
+@@ -71,7 +71,6 @@ static int worker_thread(void *arg)
+ 	    atomic_inc_not_zero(&info->wthread_ioc->refcount)) {
+ 		put_io_context(current->io_context);
+ 		current->io_context = info->wthread_ioc;
+-		atomic_inc(&info->wthread_ioc->nr_tasks);
+ 	} else
+ 		info->wthread_ioc = get_io_context(GFP_KERNEL, -1);
+ 
+@@ -107,7 +106,6 @@ static int worker_thread(void *arg)
+ 		current->io_context = NULL;
+ 		task_unlock(current);
+ 
+-		atomic_dec(&ioc->nr_tasks);
+ 		put_io_context(ioc);
+ 	}
+ 
--- iscsitarget-1.4.20.2.orig/patches/compat-2.6.30.patch
+++ iscsitarget-1.4.20.2/patches/compat-2.6.30.patch
@@ -7,5 +7,16 @@
 -		unsigned bsz = bdev_logical_block_size(bio_data->bdev);
 +		unsigned bsz = bdev_hardsect_size(bio_data->bdev);
  		if (!volume->blk_shift)
- 			volume->blk_shift = ilog2(bsz);
- 		else if (volume->blk_shift < ilog2(bsz)) {
+ 			volume->blk_shift = blksize_bits(bsz);
+ 		else if (volume->blk_shift < blksize_bits(bsz)) {
+--- ioc/kernel/wthread.c	2011-01-13 15:09:41.000000000 -0500
++++ ioc/kernel/wthread.c	2011-01-13 15:10:19.000000000 -0500
+@@ -68,7 +68,7 @@ static int worker_thread(void *arg)
+ 	DECLARE_WAITQUEUE(wait, current);
+ 
+ 	if (info->wthread_ioc &&
+-	    atomic_long_inc_not_zero(&info->wthread_ioc->refcount)) {
++	    atomic_inc_not_zero(&info->wthread_ioc->refcount)) {
+ 		put_io_context(current->io_context);
+ 		current->io_context = info->wthread_ioc;
+ 		atomic_inc(&info->wthread_ioc->nr_tasks);
--- /dev/null
+++ iscsitarget-1.4.20.2/patches/compat-2.6.38.patch
@@ -0,0 +1,44 @@
+diff --git b/kernel/block-io.c a/kernel/block-io.c
+index e24f1ca..4c6d8bd 100644
+--- b/kernel/block-io.c
++++ a/kernel/block-io.c
+@@ -56,7 +56,6 @@ blockio_make_request(struct iet_volume *volume, struct tio *tio, int rw)
+ 	struct request_queue *bdev_q = bdev_get_queue(bio_data->bdev);
+ 	struct tio_work *tio_work;
+ 	struct bio *tio_bio = NULL, *bio = NULL, *biotail = NULL;
+-	struct blk_plug plug;
+ 
+ 	u32 offset = tio->offset;
+ 	u32 size = tio->size;
+@@ -119,8 +118,6 @@ blockio_make_request(struct iet_volume *volume, struct tio *tio, int rw)
+ 		}
+ 	}
+ 
+-	blk_start_plug(&plug);
+-
+ 	/* Walk the list, submitting bios 1 by 1 */
+ 	while (tio_bio) {
+ 		bio = tio_bio;
+@@ -130,7 +127,8 @@ blockio_make_request(struct iet_volume *volume, struct tio *tio, int rw)
+ 		submit_bio(rw, bio);
+ 	}
+ 
+-	blk_finish_plug(&plug);
++	if (bdev_q && bdev_q->unplug_fn)
++		bdev_q->unplug_fn(bdev_q);
+ 
+ 	wait_for_completion(&tio_work->tio_complete);
+ 
+diff --git b/kernel/iotype.c a/kernel/iotype.c
+index 9fd69fa..b3d6117 100644
+--- b/kernel/iotype.c
++++ a/kernel/iotype.c
+@@ -9,7 +9,7 @@
+ #include "iscsi_dbg.h"
+ 
+ static LIST_HEAD(iotypes);
+-static DEFINE_RWLOCK(iotypes_lock);
++static rwlock_t iotypes_lock = RW_LOCK_UNLOCKED;
+ 
+ static struct iotype *find_iotype(const char *name)
+ {
--- iscsitarget-1.4.20.2.orig/patches/compat-2.6.22.patch
+++ iscsitarget-1.4.20.2/patches/compat-2.6.22.patch
@@ -53,7 +53,7 @@ Index: kernel/target.c
 ===================================================================
 --- a/kernel/target.c	(revision 205)
 +++ b/kernel/target.c	(working copy)
-@@ -7,6 +7,7 @@
+@@ -9,6 +9,7 @@
  #include "iscsi.h"
  #include "digest.h"
  #include "iscsi_dbg.h"
--- /dev/null
+++ iscsitarget-1.4.20.2/patches/compat-2.6.33-2.6.35.patch
@@ -0,0 +1,13 @@
+diff --git b/kernel/conn.c a/kernel/conn.c
+index c7b8ea1..ec6dada 100644
+--- b/kernel/conn.c
++++ a/kernel/conn.c
+@@ -44,7 +44,7 @@ void conn_info_show(struct seq_file *seq, struct iscsi_session *session)
+ 		switch (sk->sk_family) {
+ 		case AF_INET:
+ 			snprintf(buf, sizeof(buf),
+-				 "%pI4", &inet_sk(sk)->inet_daddr);
++				 "%u.%u.%u.%u", NIPQUAD(inet_sk(sk)->inet_daddr));
+ 			break;
+ 		case AF_INET6:
+ 			snprintf(buf, sizeof(buf), "[%pI6]",
--- /dev/null
+++ iscsitarget-1.4.20.2/patches/compat-2.6.36-2.6.37.patch
@@ -0,0 +1,34 @@
+diff --git b/kernel/block-io.c a/kernel/block-io.c
+index 4c6d8bd..c812abf 100644
+--- b/kernel/block-io.c
++++ a/kernel/block-io.c
+@@ -155,14 +155,14 @@ blockio_open_path(struct iet_volume *volume, const char *path)
+ {
+ 	struct blockio_data *bio_data = volume->private;
+ 	struct block_device *bdev;
+-	int flags = FMODE_EXCL | FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
++	int flags = FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
+ 	int err = 0;
+ 
+ 	bio_data->path = kstrdup(path, GFP_KERNEL);
+ 	if (!bio_data->path)
+ 		return -ENOMEM;
+ 
+-	bdev = blkdev_get_by_path(path, flags, THIS_MODULE);
++	bdev = open_bdev_exclusive(path, flags, THIS_MODULE);
+ 	if (IS_ERR(bdev)) {
+ 		err = PTR_ERR(bdev);
+ 		eprintk("Can't open device %s, error %d\n", path, err);
+@@ -250,10 +250,10 @@ static void
+ blockio_detach(struct iet_volume *volume)
+ {
+ 	struct blockio_data *bio_data = volume->private;
+-	int flags = FMODE_EXCL | FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
++	int flags = FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
+ 
+ 	if (bio_data->bdev)
+-		blkdev_put(bio_data->bdev, flags);
++		close_bdev_exclusive(bio_data->bdev, flags);
+ 	kfree(bio_data->path);
+ 
+ 	kfree(volume->private);
--- iscsitarget-1.4.20.2.orig/etc/ietd.conf
+++ iscsitarget-1.4.20.2/etc/ietd.conf
@@ -76,10 +76,12 @@
 	#MaxXmitDataSegmentLength 8192		# Max data per PDU to transmit
 	#MaxBurstLength		262144		# Max data per sequence (R2T)
 	#FirstBurstLength	65536		# Max unsolicited data sequence
-	#DefaultTime2Wait	2		# Secs wait for ini to log out
-						# Not used
-	#DefaultTime2Retain	20		# Secs keep cmnds after log out
-						# Not used
+	#DefaultTime2Wait	2		# Secs to wait for ini to logout
+						# also secs for ini to wait
+						# before logging back in
+						# Not implemented, but settable
+	#DefaultTime2Retain	0		# Secs keep session after logout
+						# We only support 0
 	#MaxOutstandingR2T	1		# Max outstanding R2Ts per cmnd
 	#DataPDUInOrder		Yes		# Data in PDUs is ordered
 						# We only support ordered
--- iscsitarget-1.4.20.2.orig/etc/initd/initd.gentoo
+++ iscsitarget-1.4.20.2/etc/initd/initd.gentoo
@@ -17,7 +17,7 @@ start()
 	ebegin "Starting iSCSI Target"
 	modprobe -q crc32c
 	modprobe iscsi_trgt
-	start-stop-daemon --start --exec /usr/sbin/ietd --pidfile /var/run/iscsi_trgt.pid -- $OPTIONS
+	start-stop-daemon --start --exec /usr/sbin/ietd --pidfile /var/run/ietd.pid -- $OPTIONS
 	eend $?
 }
 
@@ -25,7 +25,7 @@ stop()
 {
 	ebegin "Stopping iSCSI Target"
 	ietadm --op delete
-	start-stop-daemon --stop --exec /usr/sbin/ietd --pidfile /var/run/iscsi_trgt.pid
+	start-stop-daemon --stop --exec /usr/sbin/ietd --pidfile /var/run/ietd.pid
 	rm -f /var/run/iscsi_trgt.pid
 	eend $?
 }
--- iscsitarget-1.4.20.2.orig/etc/initd/initd.debian
+++ iscsitarget-1.4.20.2/etc/initd/initd.debian
@@ -7,7 +7,7 @@
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 DAEMON=/usr/sbin/ietd
 OPTIONS=""
-PIDFILE=/var/run/iscsi_trgt.pid
+PIDFILE=/var/run/ietd.pid
 
 if [ -f /lib/init/vars.sh ]; then
 	. /lib/init/vars.sh
--- iscsitarget-1.4.20.2.orig/etc/initd/initd
+++ iscsitarget-1.4.20.2/etc/initd/initd
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 #
 # Start the iSCSI Enterprise Target.
 #
--- iscsitarget-1.4.20.2.orig/doc/manpages/ietd.conf.5
+++ iscsitarget-1.4.20.2/doc/manpages/ietd.conf.5
@@ -40,7 +40,7 @@ Target iqn.2001\-04.com.example:storage.
     MaxBurstLength 262144
     FirstBurstLength 65536
     DefaultTime2Wait 2
-    DefaultTime2Retain 20
+    DefaultTime2Retain 0
     MaxOutstandingR2T 8
     NOPInterval 0
     NOPTimeout 0
@@ -279,10 +279,10 @@ and
 should be set to multiples of PAGE_SIZE. Configuring too large values may lead to problems allocating sufficient memory, which in turn may lead to SCSI commands timing out at the initiator host. The default value is 65536.
 .TP
 .B [DefaultTime2Wait <value>]
-Currently not supported.
+Currently not implemented, but can be used to set how long initiators wait before logging back in after a connection is logged out or dropped.
 .TP
 .B [DefaultTime2Retain <value>]
-Currently not supported.
+Currently we only support 0 which means sessions are not retained after the last connection is logged out or dropped.
 .TP
 .B [MaxOutstandingR2T <value>]
 Optional. Controls the maximum number of data transfers the target may request at once, each of up to
--- iscsitarget-1.4.20.2.orig/usr/plain.c
+++ iscsitarget-1.4.20.2/usr/plain.c
@@ -691,10 +691,12 @@ static int iscsi_param_partial_set(u32 t
 	return __plain_param_set(tid, sid, type, 1 << key, param, 0);
 }
 
-static void plain_portal_init(FILE *fp, char **isns, int *isns_ac)
+static void plain_portal_init(FILE *fp, int *timeout)
 {
 	char buf[BUFSIZE];
 	char *p, *q;
+	char *isns = NULL;
+	int isns_ac = 0;
 
 	while (fgets(buf, BUFSIZE, fp)) {
 		q = buf;
@@ -702,15 +704,16 @@ static void plain_portal_init(FILE *fp,
 		if (!p || *p == '#')
 			continue;
 		if (!strcasecmp(p, "iSNSServer")) {
-			*isns = strdup(target_sep_string(&q));
+			isns = strdup(target_sep_string(&q));
 		} else if (!strcasecmp(p, "iSNSAccessControl")) {
 			char *str = target_sep_string(&q);
 			if (!strcasecmp(str, "Yes"))
-				*isns_ac = 1;
+				isns_ac = 1;
 		}
 	}
 
-	return;
+	if (isns)
+		*timeout = isns_init(isns, isns_ac);
 }
 
 static void plain_target_init(FILE *fp)
@@ -796,7 +799,7 @@ static void plain_account_init(FILE *fp)
 	return;
 }
 
-static void plain_init(char *params, char **isns, int *isns_ac)
+static void plain_init(char *params, int *timeout)
 {
 	FILE *fp;
 	struct stat st;
@@ -826,7 +829,7 @@ static void plain_init(char *params, cha
 		}
 	}
 
-	plain_portal_init(fp, isns, isns_ac);
+	plain_portal_init(fp, timeout);
 
 	rewind(fp);
 
--- iscsitarget-1.4.20.2.orig/usr/Makefile
+++ iscsitarget-1.4.20.2/usr/Makefile
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include
 CFLAGS += -D_GNU_SOURCE # required for glibc >= 2.8
 PROGRAMS = ietd ietadm
 LIBS =
@@ -7,10 +7,10 @@ all: $(PROGRAMS)
 
 ietd: ietd.o iscsid.o conn.o session.o target.o message.o ctldev.o log.o chap.o event.o param.o plain.o isns.o md5.o sha1.o
 
-	$(CC) $^ -o $@ $(LIBS)
+	$(CC) $(LDFLAGS) $^ -o $@ $(LIBS)
 
 ietadm: ietadm.o param.o
-	$(CC) $^ -o $@
+	$(CC) $(LDFLAGS) $^ -o $@
 
 clean:
 	rm -f *.o $(PROGRAMS)
--- iscsitarget-1.4.20.2.orig/usr/param.c
+++ iscsitarget-1.4.20.2/usr/param.c
@@ -142,11 +142,15 @@ static int digest_val_to_str(unsigned in
 {
 	int err = 0;
 
-	if (val & DIGEST_CRC32C)
-		strcpy(str, "CRC32C");
-	else if (val & DIGEST_NONE)
+	if (val & DIGEST_NONE)
 		strcpy(str, "None");
-	else
+	if (val & DIGEST_CRC32C) {
+		if (strlen(str))
+			strcat(str, ",CRC32C");
+		else
+			strcpy(str, "CRC32C");
+	}
+	if (!strlen(str))
 		err = -EINVAL;
 
 	return err;
@@ -158,20 +162,18 @@ static int digest_str_to_val(char *str,
 	char *p, *q;
 	p = str;
 
-	*val = DIGEST_NONE;
+	*val = 0;
 	do {
-		if (!strncmp(p, "None", strlen("None")))
+		q = strsep(&p, ",");
+		if (!strcmp(q, "None"))
 			*val |= DIGEST_NONE;
-		else if (!strncmp(p, "CRC32C", strlen("CRC32C")))
+		else if (!strcmp(q, "CRC32C"))
 			*val |= DIGEST_CRC32C;
 		else {
 			err = -EINVAL;
 			break;
 		}
-
-		if ((q = strchr(p, ',')))
-			p = q + 1;
-	} while (q);
+	} while (p);
 
 	return err;
 }
--- iscsitarget-1.4.20.2.orig/usr/iscsid.c
+++ iscsitarget-1.4.20.2/usr/iscsid.c
@@ -273,43 +273,6 @@ static void text_scan_security(struct co
 		login_rsp_ini_err(conn, ISCSI_STATUS_AUTH_FAILED);
 }
 
-static void login_security_done(struct connection *conn)
-{
-	struct iscsi_login_req_hdr *req =
-				(struct iscsi_login_req_hdr *)&conn->req.bhs;
-	struct session *session;
-
-	if (!conn->tid)
-		return;
-
-	if ((session = session_find_name(conn->tid, conn->initiator, req->sid))) {
-		if (!req->sid.id.tsih) {
-			/* do session reinstatement */
-			log_debug(1, "session %#" PRIx64 " reinstated",
-								req->sid.id64);
-			if (session_remove(session))
-				login_rsp_tgt_err(conn, ISCSI_STATUS_TARGET_ERROR);
-			return;
-		} else if (req->sid.id.tsih != session->sid.id.tsih) {
-			/* fail the login */
-			login_rsp_ini_err(conn, ISCSI_STATUS_SESSION_NOT_FOUND);
-			return;
-		}
-		/* add connection to existing session */
-		/* reinstatement handled in kernel */
-		log_debug(1, "connection %u added to session %#" PRIx64,
-						conn->cid, req->sid.id64);
-		conn->session = session;
-	} else {
-		if (req->sid.id.tsih) {
-			/* fail the login */
-			login_rsp_ini_err(conn, ISCSI_STATUS_SESSION_NOT_FOUND);
-			return;
-		}
-		/* instantiate a new session */
-	}
-}
-
 static void text_scan_login(struct connection *conn)
 {
 	char *key, *value, *data;
@@ -510,14 +473,43 @@ static void login_start(struct connectio
 
 static void login_finish(struct connection *conn)
 {
+	struct iscsi_login_req_hdr *req =
+			(struct iscsi_login_req_hdr *)&conn->req.bhs;
+	struct session *session =
+			session_find_name(conn->tid, conn->initiator, req->sid);
+
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
+		if (session) {
+			if (!req->sid.id.tsih) {
+				/* session reinstatement */
+				log_debug(1, "session %#" PRIx64 " reinstated",
+					req->sid.id64);
+				if (session_remove(session)) {
+					login_rsp_tgt_err(conn,
+						ISCSI_STATUS_TARGET_ERROR);
+					return;
+				}
+			} else if (req->sid.id.tsih != session->sid.id.tsih) {
+				/* fail the login */
+				login_rsp_ini_err(conn,
+					ISCSI_STATUS_SESSION_NOT_FOUND);
+				return;
+			}
+			/* add connection to existing session */
+			log_debug(1, "connection %u added to session %#" PRIx64,
+				conn->cid, req->sid.id64);
+			conn->session = session;
+		} else if (req->sid.id.tsih) {
+			/* fail the login */
+			login_rsp_ini_err(conn, ISCSI_STATUS_SESSION_NOT_FOUND);
+			return;
+		}
 		/* create or re-create in case the session closed */
 		if (session_create(conn)) {
 			login_rsp_tgt_err(conn, ISCSI_STATUS_TARGET_ERROR);
 			return;
 		}
-		conn->sid = conn->session->sid;
 		break;
 	case SESSION_DISCOVERY:
 		/* set a dummy tsih value */
@@ -680,7 +672,6 @@ static void cmnd_exec_login(struct conne
 			case STATE_SECURITY:
 			case STATE_SECURITY_DONE:
 				conn->state = STATE_SECURITY_LOGIN;
-				login_security_done(conn);
 				break;
 			default:
 				goto init_err;
@@ -696,7 +687,6 @@ static void cmnd_exec_login(struct conne
 					break;
 				}
 				conn->state = STATE_SECURITY_FULL;
-				login_security_done(conn);
 				break;
 			case STATE_LOGIN:
 				if (stay)
--- iscsitarget-1.4.20.2.orig/usr/session.c
+++ iscsitarget-1.4.20.2/usr/session.c
@@ -102,8 +102,10 @@ int session_create(struct connection *co
 		session->initiator = strdup(conn->initiator);
 
 		conn->session = session;
+		conn->sid = session->sid;
 	} else {
 		session = conn->session;
+		conn->sid = session->sid;
 
 		if (session_exist(conn->tid, session->sid.id64))
 			return 0;
--- iscsitarget-1.4.20.2.orig/usr/event.c
+++ iscsitarget-1.4.20.2/usr/event.c
@@ -87,10 +87,9 @@ retry:
 
 	switch (event.state) {
 	case E_CONN_CLOSE:
-		if (!(session = session_find_id(event.tid, event.sid))) {
-			log_warning("session %llu not found?", event.sid);
-			goto retry;
-		}
+		if (!(session = session_find_id(event.tid, event.sid)))
+			/* session previously closed for reinstatement? */
+			break;
 
 		if (--session->conn_cnt <= 0)
 			session_remove(session);
--- iscsitarget-1.4.20.2.orig/usr/config.h
+++ iscsitarget-1.4.20.2/usr/config.h
@@ -29,7 +29,7 @@
 #define CONFIG_H
 
 struct config_operations {
-	void (*init) (char *, char **, int *);
+	void (*init) (char *params, int *timeout);
 	int (*target_add) (u32 *, char *);
 	int (*target_stop) (u32);
 	int (*target_del) (u32);
--- iscsitarget-1.4.20.2.orig/usr/ietd.c
+++ iscsitarget-1.4.20.2/usr/ietd.c
@@ -426,6 +426,8 @@ void event_loop(int timeout)
 				pollfd->fd = -1;
 				incoming[i] = NULL;
 				incoming_cnt--;
+				if ((poll_array[POLL_LISTEN].events == 0) && (incoming_cnt < INCOMING_MAX))
+					poll_array[POLL_LISTEN].events = POLLIN;
 				if (session && session->conn_cnt <= 0)
 					session_remove(session);
 			}
@@ -439,8 +441,7 @@ int main(int argc, char **argv)
 	char *config = NULL, pid_buf[64];
 	uid_t uid = 0;
 	gid_t gid = 0;
-	char *isns = NULL;
-	int isns_ac = 0, pid_fd;
+	int pid_fd;
 
 	/* otherwise we would die in some later write() during the event_loop
 	 * instead of getting EPIPE! */
@@ -549,10 +550,6 @@ int main(int argc, char **argv)
 		exit(-1);
 	}
 
-	cops->init(config, &isns, &isns_ac);
-	if (isns)
-		timeout = isns_init(isns, isns_ac);
-
 	if (gid && setgid(gid) < 0) {
 		log_error("unable to setgid: %m");
 		exit(-1);
@@ -563,6 +560,8 @@ int main(int argc, char **argv)
 		exit(-1);
 	}
 
+	cops->init(config, &timeout);
+
 	event_loop(timeout);
 
 	return 0;
--- iscsitarget-1.4.20.2.orig/usr/target.c
+++ iscsitarget-1.4.20.2/usr/target.c
@@ -78,6 +78,9 @@ static void target_print_addr(struct con
 {
 	char taddr[NI_MAXHOST + NI_MAXSERV + 5];
 
+	/* strip ipv6 zone id */
+	addr = strsep(&addr, "%");
+
 	snprintf(taddr, sizeof(taddr),
 		(family == AF_INET) ? "%s:%d,1" : "[%s]:%d,1",
 							addr, server_port);
--- iscsitarget-1.4.20.2.orig/usr/conn.c
+++ iscsitarget-1.4.20.2/usr/conn.c
@@ -51,7 +51,7 @@ void conn_take_fd(struct connection *con
 			      conn->session_param[key_data_digest].val);
 	if (!err)
 		conn->session->conn_cnt++;
-	else if (err < 0 && err != -EEXIST)
+	else
 		log_error("unable to create connection %u for session %#" PRIx64 " in target %u: %d",
 			conn->cid, conn->session->sid.id64, conn->tid, errno);
 
